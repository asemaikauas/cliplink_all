import os
import json
import httpx
from pathlib import Path
from typing import Dict, Any, List
from dotenv import load_dotenv
import asyncio
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

load_dotenv()
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

# REMOVED: extract_subtitles_for_segments function - subtitles are now generated by Groq instead

async def analyze_transcript_with_gemini(transcript_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Analyze transcript using Gemini AI to generate viral video segments
    """
    if not GEMINI_API_KEY:
        raise ValueError("GEMINI_API_KEY environment variable not set")

    # Extract data for prompt
    title = transcript_data.get('title', '')
    description = transcript_data.get('description', '')
    category = transcript_data.get('category', '')
    transcript = transcript_data.get('transcript', '')
    timecodes = transcript_data.get('timecodes', [])

    print(f"\nü§ñ –ê–Ω–∞–ª–∏–∑ –≤–∏–¥–µ–æ —Å Gemini AI:")
    print(f"üì∫ –ù–∞–∑–≤–∞–Ω–∏–µ: {title}")
    print(f"üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category}")
    print(f"üìÑ –î–ª–∏–Ω–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: {len(transcript)} —Å–∏–º–≤–æ–ª–æ–≤")
    print(f"‚è±Ô∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∞–π–º–∫–æ–¥–æ–≤: {len(timecodes)}")

    prompt = f"""

     You are a senior expert in video editing and screenwriting and 
     story producer for social networks (TikTok, YouTube Shorts, Reels) with 10 
     years of experience.

     Your task is to analyze the full text transcription, title, description and category of the Youtube Video and construct up to 10 viral short videos 
     with a clear storyline, selecting the catchy and sensational moments to drive people watch the full video. Video should start with a "hook" in the 
     first 3-7 seconds that contains provocative, catching attention information. Each video should have one unique idea, story or theme. Provide 
     duration of each selected video segment in seconds with start and end timecodes. 

     VIDEO INFORMATION:
     Title: {title}
     Description: {description}
     Category: {category}
     
     TRANSCRIPT:
     {transcript}

     TIMECODES: 
     {timecodes}
     
     INSTRUCTIONS:
     Analyze the transcript for viral moments, hooks, and engaging content, create 3-10 short video segments (40 seconds to 80 seconds maximum each) depending 
     on the length of the video and truly viral moments, focus on controversial, surprising, educational, or entertaining moments, use the timecodes 
     to select precise start/end times in seconds. Make sure that selected video segments are not overlappping, and that they tell one story. You shoudld 
     make sure that segments contains logically complete sentences (it should not abruptly start or abruptly end). 
     Segment must not be more than 80-90 seconds. Create 6 and more segments if the video is longer than 1 hour (60 minutes).  

     1. Use the transcript + timecodes to pick exact start & end in seconds (floats not allowed).  
     2. Duration for every segment: 40 ‚â§ (end ‚àí start) ‚â§ 90.  
     3. Create 6 and more segments if and only if the video is longer than 1 hour (60 minutes).

     
     Output Format: 
     {{
         "viral_segments": [
             {{
                 "title": "Catchy title for the segment",
                 "start": 0,
                 "end": 45
             }}
         ]
     }}
     
     Remember: Return ONLY the JSON object, no additional text or explanations."""

    # Use the correct Gemini 2.5 Pro preview model name from the API list
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-06-05:generateContent?key={GEMINI_API_KEY}"
    
    headers = {
        "Content-Type": "application/json"
    }
    
    data = {
        "contents": [
            {
                "parts": [
                    {
                        "text": prompt
                    }
                ]
            }
        ],
        "generationConfig": {
            "temperature": 1.2,
            "topP": 0.9,
            "topK": 40,
            "maxOutputTokens": 65535
        }
    }
    
    print(f"\nüöÄ –û—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –∫ Gemini API...")
    
    # Configure client with better connection settings
    timeout_config = httpx.Timeout(
        timeout=300.0,  # Reduced overall timeout
        connect=30.0,   # Connection timeout
        read=240.0,     # Read timeout
        write=30.0      # Write timeout
    )
    
    # Configure retry settings with exponential backoff
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10),
        retry=retry_if_exception_type((httpx.ReadError, httpx.ConnectError, httpx.TimeoutException, httpx.NetworkError))
    )
    async def make_gemini_request():
        async with httpx.AsyncClient(
            timeout=timeout_config,
            limits=httpx.Limits(max_keepalive_connections=5, max_connections=10)
        ) as client:
            response = await client.post(url, headers=headers, json=data)
            response.raise_for_status()
            return response.json()

    try:
        gemini_response = await make_gemini_request()
        
        if 'candidates' in gemini_response and len(gemini_response['candidates']) > 0:
            candidate = gemini_response['candidates'][0]
            if 'content' in candidate and 'parts' in candidate['content']:
                generated_text = candidate['content']['parts'][0]['text']
                
                print(f"‚úÖ –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç Gemini ({len(generated_text)} —Å–∏–º–≤–æ–ª–æ–≤)")
                
                # Clean up the response (remove markdown code blocks if present)
                generated_text = generated_text.strip()
                if generated_text.startswith('```json'):
                    generated_text = generated_text[7:]
                if generated_text.startswith('```'):
                    generated_text = generated_text[3:]
                if generated_text.endswith('```'):
                    generated_text = generated_text[:-3]
                generated_text = generated_text.strip()
                  
                try:
                    viral_analysis = json.loads(generated_text)
                    
                    print(f"\nüéØ Gemini found {len(viral_analysis.get('viral_segments', []))} viral segments")
                    
                    # Add duration calculation for each segment (no subtitle extraction needed)
                    if 'viral_segments' in viral_analysis:
                        optimized_segments = []
                        for segment in viral_analysis['viral_segments']:
                            start_time = segment.get('start', 0)
                            end_time = segment.get('end', 0)
                            
                            # Add duration calculation
                            optimized_segment = {
                                "title": segment.get("title", "Untitled"),
                                "start": start_time,
                                "end": end_time,
                                "duration": end_time - start_time
                            }
                            optimized_segments.append(optimized_segment)
                        
                        viral_analysis['viral_segments'] = optimized_segments
                        
                        print(f"\nüìã OPTIMIZED JSON (title, start, end, duration only):")
                        print("=" * 60)
                        print(json.dumps(viral_analysis, ensure_ascii=False, indent=2))
                        print("=" * 60)
                        print(f"üöÄ OPTIMIZATION: Removed subtitle extraction - subtitles generated by Groq instead")
                    else:
                        print(f"‚ö†Ô∏è No viral segments found in Gemini response")
                    
                    # Combine original data with Gemini analysis
                    result = {
                        "gemini_analysis": viral_analysis
                    }
                    
                    return result
                    
                except json.JSONDecodeError as e:
                    print(f"‚ùå JSON decode error: {e}")
                    print(f"‚ùå Generated text: {generated_text}")
                    return {
                        "gemini_analysis": {
                            "error": "Failed to parse Gemini response",
                            "raw_response": generated_text
                        }
                    }
        
        print(f"‚ùå –ù–µ—Ç –≤–∞–ª–∏–¥–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞ –æ—Ç Gemini")
        return {
            "gemini_analysis": {
                "error": "No valid response from Gemini",
                "raw_response": gemini_response
            }
        }
        
    except httpx.HTTPStatusError as e:
        error_detail = ""
        try:
            error_response = e.response.json()
            error_detail = json.dumps(error_response, indent=2)
        except:
            error_detail = e.response.text
        
        print(f"‚ùå Gemini API error {e.response.status_code}: {error_detail}")
        raise Exception(f"Gemini API error {e.response.status_code}: {error_detail}")
    except httpx.TimeoutException:
        print(f"‚è±Ô∏è Gemini API request timed out after multiple retries")
        raise Exception("Gemini API request timed out after multiple retries")
    except (httpx.ReadError, httpx.ConnectError, httpx.NetworkError) as e:
        print(f"‚ùå Network error calling Gemini API: {str(e)}")
        raise Exception(f"Network error calling Gemini API: {str(e)}")
    except Exception as e:
        print(f"‚ùå Unexpected error calling Gemini API: {str(e)}")
        raise Exception(f"Unexpected error calling Gemini API: {str(e)}") 